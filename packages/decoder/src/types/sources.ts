/**
 * Source tracking types for data provenance in the decoder.
 * Each piece of data can be wrapped with source information indicating
 * where it came from (calldata, Etherscan, on-chain, etc.)
 */

/** Base source with optional timestamp */
type BaseSource = {
  /** Unix timestamp when the data was fetched (milliseconds) */
  timestamp?: number;
};

/** Data extracted directly from proposal calldata */
export type CalldataSource = BaseSource & {
  type: "calldata";
  /** Byte offset from start of calldata (after 0x prefix) */
  offset: number;
  /** Length in bytes */
  length: number;
  /** Raw hex bytes (with 0x prefix) */
  rawBytes: string;
  /** How the data was encoded */
  encoding: "abi" | "raw" | "selector";
};

/** ABI fetched from Etherscan API */
export type EtherscanAbiSource = BaseSource & {
  type: "etherscan-abi";
  chainId: number;
  address: string;
  /** API endpoint used */
  endpoint: string;
};

/** Address tag/label from Etherscan nametag API */
export type EtherscanTagSource = BaseSource & {
  type: "etherscan-tag";
  chainId: number;
  address: string;
  /** Type of tag (nametag, label, etc.) */
  tagType: "nametag" | "label" | "attribute";
};

/** Contract name from Etherscan source code API */
export type EtherscanSourcecodeSource = BaseSource & {
  type: "etherscan-sourcecode";
  chainId: number;
  address: string;
  /** Whether the contract is verified */
  verified: boolean;
};

/** Data fetched via RPC call to the blockchain */
export type OnChainSource = BaseSource & {
  type: "on-chain";
  chainId: number;
  /** Contract address called */
  target: string;
  /** Method signature called */
  method: string;
  /** Parameters passed to the call */
  params: unknown[];
  /** Cast command to replicate the call */
  castCommand: string;
};

/** Data from static metadata files (vendor/comet config) */
export type StaticMetadataSource = BaseSource & {
  type: "static-metadata";
  /** Path relative to monorepo root */
  filePath: string;
  /** JSON key path (e.g. "assets.USDC.address") */
  key: string;
  /** Market name if applicable */
  market?: string;
};

/** Data generated by a decoder handler */
export type HandlerSource = BaseSource & {
  type: "handler";
  /** Name of the handler that produced this */
  handlerName: string;
  /** Human-readable description of how it was computed */
  description?: string;
};

/** Data derived/computed from other sourced values */
export type DerivedSource = BaseSource & {
  type: "derived";
  /** Description of the derivation logic */
  logic: string;
  /** Sources of the input values */
  inputs: DataSource[];
};

/** Data from external APIs (DefiLlama, etc.) */
export type ExternalApiSource = BaseSource & {
  type: "external-api";
  /** API name (e.g. "defillama") */
  api: string;
  /** Full endpoint URL */
  endpoint: string;
};

/** Hardcoded constants in the codebase */
export type HardcodedSource = BaseSource & {
  type: "hardcoded";
  /** File location (package/path:line) */
  location: string;
  /** Why this is hardcoded */
  description?: string;
};

/** ABI from local fallback files */
export type LocalAbiSource = BaseSource & {
  type: "local-abi";
  /** Path relative to monorepo root */
  filePath: string;
  /** Contract name if known */
  contractName?: string;
};

/** Data from proposal execute() parameters (targets[], values[], calldatas[]) */
export type ProposalParameterSource = BaseSource & {
  type: "proposal-parameter";
  /** Which parameter array: targets, values, or calldatas */
  parameter: "targets" | "values" | "calldatas";
  /** Index in the array (action number) */
  index: number;
  /** Raw value as hex string */
  rawValue: string;
};

/** Discriminated union of all source types */
export type DataSource =
  | CalldataSource
  | EtherscanAbiSource
  | EtherscanTagSource
  | EtherscanSourcecodeSource
  | OnChainSource
  | StaticMetadataSource
  | HandlerSource
  | DerivedSource
  | ExternalApiSource
  | HardcodedSource
  | LocalAbiSource
  | ProposalParameterSource;

/**
 * Wrapper type for values with source tracking.
 * When trackSources is enabled, fields become Sourced<T> instead of T.
 */
export type Sourced<T> = {
  value: T;
  source: DataSource;
};

/**
 * Create a sourced value.
 * @param value The actual value
 * @param source Where the value came from
 */
export function sourced<T>(value: T, source: DataSource): Sourced<T> {
  return {
    value,
    source: {
      ...source,
      timestamp: source.timestamp ?? Date.now(),
    },
  };
}

/**
 * Type guard to check if a value is sourced.
 */
export function isSourced<T>(val: T | Sourced<T>): val is Sourced<T> {
  return (
    val !== null &&
    typeof val === "object" &&
    "value" in val &&
    "source" in val &&
    typeof (val as Sourced<T>).source === "object" &&
    "type" in (val as Sourced<T>).source
  );
}

/**
 * Unwrap a potentially sourced value to get the raw value.
 * If the value is not sourced, returns it as-is.
 */
export function unwrap<T>(val: T | Sourced<T>): T {
  if (isSourced(val)) {
    return val.value;
  }
  return val;
}

/**
 * Get the source from a potentially sourced value.
 * Returns undefined if the value is not sourced.
 */
export function getSource<T>(val: T | Sourced<T>): DataSource | undefined {
  if (isSourced(val)) {
    return val.source;
  }
  return undefined;
}

/**
 * Map a function over a sourced value, preserving the source.
 */
export function mapSourced<T, U>(
  val: Sourced<T>,
  fn: (value: T) => U
): Sourced<U> {
  return {
    value: fn(val.value),
    source: val.source,
  };
}

/**
 * Combine multiple sourced values into a derived sourced value.
 */
export function deriveSourced<T>(
  value: T,
  logic: string,
  ...inputs: (Sourced<unknown> | DataSource)[]
): Sourced<T> {
  const inputSources = inputs.map((input) =>
    isSourced(input) ? input.source : input
  );
  return sourced(value, {
    type: "derived",
    logic,
    inputs: inputSources,
  });
}

// =============================================================================
// Source creation helpers
// =============================================================================

/** Create a calldata source */
export function calldataSource(
  offset: number,
  length: number,
  rawBytes: string,
  encoding: "abi" | "raw" | "selector" = "abi"
): CalldataSource {
  return { type: "calldata", offset, length, rawBytes, encoding };
}

/** Create an Etherscan ABI source */
export function etherscanAbiSource(
  chainId: number,
  address: string
): EtherscanAbiSource {
  return {
    type: "etherscan-abi",
    chainId,
    address,
    endpoint: `https://api.etherscan.io/v2/api?module=contract&action=getabi&chainid=${chainId}&address=${address}`,
  };
}

/** Create an Etherscan tag source */
export function etherscanTagSource(
  chainId: number,
  address: string,
  tagType: "nametag" | "label" | "attribute"
): EtherscanTagSource {
  return { type: "etherscan-tag", chainId, address, tagType };
}

/** Create an Etherscan sourcecode source */
export function etherscanSourcecodeSource(
  chainId: number,
  address: string,
  verified: boolean
): EtherscanSourcecodeSource {
  return { type: "etherscan-sourcecode", chainId, address, verified };
}

/** Create an on-chain source */
export function onChainSource(
  chainId: number,
  target: string,
  method: string,
  params: unknown[],
  rpcEnvVar?: string
): OnChainSource {
  const rpcVar = rpcEnvVar ?? getRpcEnvVar(chainId);
  const paramsStr = params.map((p) => `"${p}"`).join(" ");
  return {
    type: "on-chain",
    chainId,
    target,
    method,
    params,
    castCommand: `cast call ${target} "${method}" ${paramsStr} --rpc-url $${rpcVar}`,
  };
}

/** Create a static metadata source */
export function staticMetadataSource(
  filePath: string,
  key: string,
  market?: string
): StaticMetadataSource {
  return { type: "static-metadata", filePath, key, market };
}

/** Create a handler source */
export function handlerSource(
  handlerName: string,
  description?: string
): HandlerSource {
  return { type: "handler", handlerName, description };
}

/** Create an external API source */
export function externalApiSource(
  api: string,
  endpoint: string
): ExternalApiSource {
  return { type: "external-api", api, endpoint };
}

/** Create a hardcoded source */
export function hardcodedSource(
  location: string,
  description?: string
): HardcodedSource {
  return { type: "hardcoded", location, description };
}

/** Create a local ABI source */
export function localAbiSource(
  filePath: string,
  contractName?: string
): LocalAbiSource {
  return { type: "local-abi", filePath, contractName };
}

/** Create a proposal parameter source */
export function proposalParameterSource(
  parameter: "targets" | "values" | "calldatas",
  index: number,
  rawValue: string
): ProposalParameterSource {
  return { type: "proposal-parameter", parameter, index, rawValue };
}

// Helper to get RPC env var name for a chain
function getRpcEnvVar(chainId: number): string {
  const vars: Record<number, string> = {
    1: "ETH_RPC_URL",
    10: "OP_RPC_URL",
    130: "UNICHAIN_RPC_URL",
    137: "POLYGON_RPC_URL",
    2020: "RONIN_RPC_URL",
    5000: "MANTLE_RPC_URL",
    8453: "BASE_RPC_URL",
    42161: "ARB_RPC_URL",
    59144: "LINEA_RPC_URL",
    534352: "SCROLL_RPC_URL",
  };
  return vars[chainId] ?? "ETH_RPC_URL";
}
