/**
 * Serialized source types for the portal frontend.
 * These mirror the decoder source types but are optimized for JSON serialization
 * and frontend display.
 */

/** Base source with optional timestamp */
type BaseSource = {
  timestamp?: number;
};

/** Data extracted directly from proposal calldata */
export type CalldataSource = BaseSource & {
  type: "calldata";
  offset: number;
  length: number;
  rawBytes: string;
  encoding: "abi" | "raw" | "selector";
};

/** ABI fetched from Etherscan API */
export type EtherscanAbiSource = BaseSource & {
  type: "etherscan-abi";
  chainId: number;
  address: string;
  endpoint: string;
};

/** Address tag/label from Etherscan nametag API */
export type EtherscanTagSource = BaseSource & {
  type: "etherscan-tag";
  chainId: number;
  address: string;
  tagType: "nametag" | "label" | "attribute";
};

/** Contract name from Etherscan source code API */
export type EtherscanSourcecodeSource = BaseSource & {
  type: "etherscan-sourcecode";
  chainId: number;
  address: string;
  verified: boolean;
};

/** Data fetched via RPC call to the blockchain */
export type OnChainSource = BaseSource & {
  type: "on-chain";
  chainId: number;
  target: string;
  method: string;
  params: unknown[];
  castCommand: string;
};

/** Data from static metadata files (vendor/comet config) */
export type StaticMetadataSource = BaseSource & {
  type: "static-metadata";
  filePath: string;
  key: string;
  market?: string;
};

/** Data generated by a decoder handler */
export type HandlerSource = BaseSource & {
  type: "handler";
  handlerName: string;
  description?: string;
};

/** Data derived/computed from other sourced values */
export type DerivedSource = BaseSource & {
  type: "derived";
  logic: string;
  inputs: DataSource[];
};

/** Data from external APIs (DefiLlama, etc.) */
export type ExternalApiSource = BaseSource & {
  type: "external-api";
  api: string;
  endpoint: string;
};

/** Hardcoded constants in the codebase */
export type HardcodedSource = BaseSource & {
  type: "hardcoded";
  location: string;
  description?: string;
};

/** ABI from local fallback files */
export type LocalAbiSource = BaseSource & {
  type: "local-abi";
  filePath: string;
  contractName?: string;
};

/** Data from proposal execute() parameters */
export type ProposalParameterSource = BaseSource & {
  type: "proposal-parameter";
  /** Which parameter: targets, values, or calldatas */
  parameter: "targets" | "values" | "calldatas";
  /** Index in the array (action number) */
  index: number;
  /** Raw value as hex string */
  rawValue: string;
};

/** Discriminated union of all source types */
export type DataSource =
  | CalldataSource
  | EtherscanAbiSource
  | EtherscanTagSource
  | EtherscanSourcecodeSource
  | OnChainSource
  | StaticMetadataSource
  | HandlerSource
  | DerivedSource
  | ExternalApiSource
  | HardcodedSource
  | LocalAbiSource
  | ProposalParameterSource;

/**
 * Wrapper type for values with source tracking.
 */
export type Sourced<T> = {
  value: T;
  source: DataSource;
};

/**
 * Type guard to check if a value is sourced.
 */
export function isSourced<T>(val: T | Sourced<T>): val is Sourced<T> {
  return (
    val !== null &&
    typeof val === "object" &&
    "value" in val &&
    "source" in val &&
    typeof (val as Sourced<T>).source === "object" &&
    "type" in (val as Sourced<T>).source
  );
}

/**
 * Unwrap a potentially sourced value to get the raw value.
 */
export function unwrap<T>(val: T | Sourced<T>): T {
  if (isSourced(val)) {
    return val.value;
  }
  return val;
}

/**
 * Get the source from a potentially sourced value.
 */
export function getSource<T>(val: T | Sourced<T>): DataSource | undefined {
  if (isSourced(val)) {
    return val.source;
  }
  return undefined;
}

/**
 * Get human-readable label for a source type.
 */
export function getSourceLabel(source: DataSource): string {
  switch (source.type) {
    case "calldata":
      return "Calldata";
    case "etherscan-abi":
      return "Etherscan ABI";
    case "etherscan-tag":
      return "Etherscan Tag";
    case "etherscan-sourcecode":
      return "Etherscan Source";
    case "on-chain":
      return "On-chain";
    case "static-metadata":
      return "Config File";
    case "handler":
      return "Handler";
    case "derived":
      return "Derived";
    case "external-api":
      return `${source.api} API`;
    case "hardcoded":
      return "Hardcoded";
    case "local-abi":
      return "Local ABI";
    default:
      return "Unknown";
  }
}

/**
 * Get explorer URL for a chain.
 */
export function getExplorerUrl(chainId: number, address?: string): string {
  const explorers: Record<number, string> = {
    1: "https://etherscan.io",
    10: "https://optimistic.etherscan.io",
    137: "https://polygonscan.com",
    8453: "https://basescan.org",
    42161: "https://arbiscan.io",
    59144: "https://lineascan.build",
    534352: "https://scrollscan.com",
    5000: "https://explorer.mantle.xyz",
    130: "https://unichain.blockscout.com",
    2020: "https://app.roninchain.com",
  };
  const base = explorers[chainId] ?? "https://etherscan.io";
  return address ? `${base}/address/${address}` : base;
}

/**
 * Get chain name for display.
 */
export function getChainName(chainId: number): string {
  const names: Record<number, string> = {
    1: "Ethereum",
    10: "Optimism",
    137: "Polygon",
    8453: "Base",
    42161: "Arbitrum",
    59144: "Linea",
    534352: "Scroll",
    5000: "Mantle",
    130: "Unichain",
    2020: "Ronin",
  };
  return names[chainId] ?? `Chain ${chainId}`;
}
